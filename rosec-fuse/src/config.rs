//! SSH config snippet generation.
//!
//! For each vault item that has at least one `custom.ssh_host` field, a
//! `.conf` snippet is generated containing one `Host` block per host pattern.
//!
//! **Conflict resolution**: if multiple vault items claim the same host
//! pattern, the item with the most recent `revision_date` wins.  Older items
//! have that `Host` block omitted from their snippet.

use std::collections::HashMap;
use std::path::Path;
use std::time::SystemTime;

use rosec_ssh_agent::KeyEntry;

use crate::naming::normalise_item_name;

/// A generated SSH config snippet.
#[derive(Debug, Clone)]
pub struct ConfigSnippet {
    /// Normalised filename (without `.conf` extension).
    pub filename_stem: String,

    /// Complete file content.
    pub content: String,
}

/// Build config snippets for all entries that have `ssh_hosts`.
///
/// `agent_sock` is the resolved path to the rosec SSH agent socket (e.g.
/// `/run/user/1000/rosec/ssh/agent.sock`).
///
/// `keys_by_name_dir` is the resolved path to `keys/by-name/` in the FUSE
/// mount (e.g. `/run/user/1000/rosec/ssh/keys/by-name`).
///
/// Returns one [`ConfigSnippet`] per vault item that has at least one
/// `ssh_host` field (or a comment-only snippet if all its hosts were claimed
/// by newer items).
pub fn build_config_snippets(
    entries: &[&KeyEntry],
    agent_sock: &Path,
    keys_by_name_dir: &Path,
) -> Vec<ConfigSnippet> {
    // Determine which item owns each host pattern (most recent revision wins).
    // Map: host_pattern → (item_name, revision_date)
    let mut host_owner: HashMap<String, (&str, Option<SystemTime>)> = HashMap::new();

    for entry in entries {
        for host in &entry.ssh_hosts {
            let should_replace = match host_owner.get(host.as_str()) {
                None => true,
                Some((_, existing_date)) => is_newer(entry.revision_date, *existing_date),
            };
            if should_replace {
                host_owner.insert(host.clone(), (&entry.item_name, entry.revision_date));
            }
        }
    }

    // Build snippets
    let mut snippets = Vec::new();

    for entry in entries {
        if entry.ssh_hosts.is_empty() {
            continue;
        }

        let stem = normalise_item_name(&entry.item_name);
        let revision_str = format_revision(entry.revision_date);

        let mut content = format!(
            "# Auto-generated by rosec — do not edit\n# Source: {} (last updated: {})\n",
            entry.item_name, revision_str
        );

        let key_file = keys_by_name_dir.join(format!("{}.pub", entry.item_name));
        let agent_sock_str = agent_sock.display().to_string();
        let key_file_str = key_file.display().to_string();

        let mut owned_hosts = Vec::new();
        let mut lost_hosts = Vec::new();

        for host in &entry.ssh_hosts {
            match host_owner.get(host.as_str()) {
                Some((owner, _)) if *owner == entry.item_name => {
                    owned_hosts.push(host.as_str());
                }
                Some((owner, _)) => {
                    lost_hosts.push((host.as_str(), *owner));
                }
                None => {
                    owned_hosts.push(host.as_str());
                }
            }
        }

        for host in owned_hosts {
            content.push('\n');
            content.push_str(&format!("Host {host}\n"));
            content.push_str(&format!("    IdentityFile {key_file_str}\n"));
            content.push_str(&format!("    IdentityAgent {agent_sock_str}\n"));
            content.push_str("    IdentitiesOnly yes\n");
        }

        if !lost_hosts.is_empty() {
            content.push('\n');
            content
                .push_str("# The following host patterns were omitted because a more recently\n");
            content.push_str("# updated vault item claims them:\n");
            for (host, owner) in lost_hosts {
                content.push_str(&format!("#   {host}  (owned by: {owner})\n"));
            }
        }

        snippets.push(ConfigSnippet {
            filename_stem: stem,
            content,
        });
    }

    snippets
}

/// Returns `true` if `candidate` is strictly newer than `existing`.
fn is_newer(candidate: Option<SystemTime>, existing: Option<SystemTime>) -> bool {
    match (candidate, existing) {
        (Some(c), Some(e)) => c > e,
        (Some(_), None) => true,  // candidate has a date, existing doesn't
        (None, Some(_)) => false, // existing has a date, candidate doesn't
        (None, None) => false,    // tie goes to the first seen (existing wins)
    }
}

/// Format a `SystemTime` as an ISO 8601 UTC string, or `"unknown"`.
fn format_revision(time: Option<SystemTime>) -> String {
    match time {
        None => "unknown".to_string(),
        Some(t) => {
            match t.duration_since(SystemTime::UNIX_EPOCH) {
                Err(_) => "unknown".to_string(),
                Ok(dur) => {
                    let secs = dur.as_secs();
                    // Simple ISO 8601 formatting without chrono dependency.
                    // Compute year/month/day/hour/min/sec from Unix timestamp.
                    format_unix_timestamp(secs)
                }
            }
        }
    }
}

/// Minimal ISO 8601 UTC timestamp formatter (avoids pulling in chrono here).
fn format_unix_timestamp(secs: u64) -> String {
    // Days from epoch
    let days = secs / 86400;
    let time_of_day = secs % 86400;
    let hour = time_of_day / 3600;
    let minute = (time_of_day % 3600) / 60;
    let second = time_of_day % 60;

    // Gregorian calendar computation
    let (year, month, day) = days_to_ymd(days);

    format!("{year:04}-{month:02}-{day:02}T{hour:02}:{minute:02}:{second:02}Z")
}

/// Convert days-since-epoch to (year, month, day).
fn days_to_ymd(days: u64) -> (u64, u64, u64) {
    // Algorithm from https://www.researchgate.net/publication/316558298
    let z = days + 719468;
    let era = z / 146097;
    let doe = z % 146097;
    let yoe = (doe - doe / 1460 + doe / 36524 - doe / 146096) / 365;
    let y = yoe + era * 400;
    let doy = doe - (365 * yoe + yoe / 4 - yoe / 100);
    let mp = (5 * doy + 2) / 153;
    let d = doy - (153 * mp + 2) / 5 + 1;
    let m = if mp < 10 { mp + 3 } else { mp - 9 };
    let y = if m <= 2 { y + 1 } else { y };
    (y, m, d)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn format_known_timestamp() {
        // 2025-01-15 12:10:00 UTC = 1736943000
        let s = format_unix_timestamp(1_736_943_000);
        assert_eq!(s, "2025-01-15T12:10:00Z");
    }

    #[test]
    fn is_newer_logic() {
        let t1 = SystemTime::UNIX_EPOCH + std::time::Duration::from_secs(1000);
        let t2 = SystemTime::UNIX_EPOCH + std::time::Duration::from_secs(2000);
        assert!(is_newer(Some(t2), Some(t1)));
        assert!(!is_newer(Some(t1), Some(t2)));
        assert!(is_newer(Some(t1), None));
        assert!(!is_newer(None, Some(t1)));
        assert!(!is_newer(None, None));
    }
}
